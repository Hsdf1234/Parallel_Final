二维数组版本：
Size = 200: 7.0995ms
Size = 500: 108.391ms
Size = 1000: 907.943ms
Size = 2000: 7528.58ms
Size = 3000: 26544.5ms

二维 vector 版本：
Size = 200: 42.452ms
Size = 500: 641.702ms
Size = 1000: 4938.17ms
Size = 2000: 40882.3ms
Size = 3000: 146452ms

一维 vector 版本：
Size = 200: 22.6237ms
Size = 500: 361.46ms
Size = 1000: 2775.82ms
Size = 2000: 22507.3ms
Size = 3000: 110799ms

这主要是因为二维数组在内存布局上更加紧凑，数据是连续存储的，而二维 vector 存储的数据在内存中是分散存放的。对于较小的问题规模（如 Size = 200），二维 vector 的性能损失相对较小，因为内存访问的开销较小，数据可以较好地缓存在 cache 中，能够充分利用空间局部性。但是，随着问题规模的增加，二维 vector 在内存访问方面的性能劣势开始显现。由于数据的离散存储，二维 vector 的访问需要更多的内存跳转，导致 cache 未命中的次数增加，进而导致较差的性能。

在 vector 中，数据块是连续存放的，但是 vector 本身只保存指向数据块的指针。vector 建立在栈上，而保存数据的数据块在堆上。因此，在二维动态数组 vector<vector<float>> 中，指向行的所有指针是连续存放的，每个行的数据是连续存放的，但是行与行之间是不连续存放的。因此，跨行访问时空间局部性降低，Cache 命中率下降，导致更多的访存开销。

同时，我们注意到，使用一维的 vector（元素连续存储）虽然相对于使用二维 vector 有一定的优化，但是性能依旧较差。一维 vector 和一维数组的效率差异主要是由于 vector 对象本身的开销和额外的内存管理操作所导致的。与一维数组相比，vector 需要存储更多的元数据，例如容量大小、元素个数等信息。此外，vector 对象需要动态分配内存，并在需要时进行内存重新分配和元素移动，以保证容器的动态扩展。这些额外的开销和操作会导致一维 vector 的性能相对较差。